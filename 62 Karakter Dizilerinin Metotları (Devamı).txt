
Karakter Dizilerinin Metotlarý (Devamý)

Karakter dizileri konusunun 4. bölümüne geldik. Bu bölümde de karakter dizilerinin metotlarýný incelemeye devam edeceðiz.


str.maketrans(), translate()

Bu iki metot birbiriyle baðlantýlý olduðu ve genellikle birlikte kullanýldýðý için, bunlarý bir arada göreceðiz.

Dilerseniz bu iki metodun ne iþe yaradýðýný anlatmaya çalýþmak yerine bir örnek üzerinden bu metotlarýn görevini anlamayý deneyelim.

Þöyle bir vaka hayal edin: Bildiðiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamýyoruz. Böyle durumlarda, elimizdeki bir metni, cümleyi veya kelimeyi Türkçe karakter içermeyecek bir hale getirmemiz gerekebiliyor. Örneðin þu cümleyi ele alalým:

Bildiðiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamýyoruz.

Ýþte buna benzer bir cümleyi kimi zaman Türkçe karakterlerinden arýndýrmak zorunda kalabiliyoruz. Eðer elinizde Türkçe yazýlmýþ bir metin varsa ve sizin amacýnýz bu metin içinde geçen Türkçeye özgü karakterleri noktasýz benzerleriyle deðiþtirmek ise str.maketrans() ve translate() metotlarýndan yararlanabilirsiniz.

Örneðimiz þu cümle idi:

Bildiðiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamýyoruz.

Amacýmýz bu cümleyi þu þekilde deðiþtirmek:

Bildiginiz gibi, internet uzerinde bazen Turkce karakterleri kullanamiyoruz.

Bunun için þöyle bir kod yazabilirsiniz:

kaynak = "þçöðüýÞÇÖÐÜÝ"
hedef = "scoguiSCOGUI"

çeviri_tablosu = str.maketrans(kaynak, hedef)

metin = "Bildiðiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamýyoruz."

print(metin.translate(çeviri_tablosu))

Bu kodlarý çalýþtýrdýðýmýzda þöyle bir çýktý elde ederiz:

Bildiginiz gibi, internet uzerinde bazen Turkce karakterleri kullanamiyoruz.

Gördüðünüz gibi, “kaynak” adlý karakter dizisi içinde belirttiðimiz bütün harfler “hedef” adlý karakter dizisi içindeki harflerle tek tek deðiþtirildi. Böylece Türkçeye özgü karakterleri (‘þçöðüýÞÇÖÐÜÝ’) en yakýn noktasýz benzerleriyle (‘scoguiSCOGUI’) deðiþtirmiþ olduk.

Peki yukarýda nasýl bir süreç iþledi de biz istediðimiz sonucu elde edebildik. Dilerseniz yukarýdaki kodlara biraz daha yakýndan bakalým. Mesela çeviri_tablosu adlý deðiþkenin çýktýsýna bakarak str.maketrans() metodunun alttan alta neler karýþtýrdýðýný görelim:

kaynak = "þçöðüýÞÇÖÐÜÝ"
hedef = "scoguiSCOGUI"

çeviri_tablosu = str.maketrans(kaynak, hedef)

print(çeviri_tablosu)

Bu kodlarý çalýþtýrdýðýmýzda þöyle bir çýktý alýyoruz:

{214: 79, 231: 99, 220: 85, 199: 67, 304: 73, 305: 105,
286: 71, 246: 111, 351: 115, 252: 117, 350: 83, 287: 103}

Bu çýktý size tamamen anlamsýz görünmüþ olabilir. Ama aslýnda son derece anlamlý ve bir o kadar da önemli bir çýktýdýr bu. Gelin isterseniz bu çýktýnýn yapýsýný biraz inceleyelim. (Buna benzer bir çýktýyý sorted() metodunu incelerken de görmüþtük)

Gördüðünüz gibi, tamamen sayýlardan oluþan bir çýktý bu. Burada birbirlerinden virgül ile ayrýlmýþ sayý çiftleri görüyoruz. Bu sayý çiftlerini daha net görebilmek için bu çýktýyý derli toplu bir hale getirelim:

{214: 79,
231: 99,
220: 85,
199: 67,
304: 73,
305: 105,
286: 71,
246: 111,
351: 115,
252: 117,
350: 83,
287: 103}

Bu þekilde sanýrým çýktýmýz biraz daha anlam kazandý. Gördüðünüz gibi, iki nokta üst üste iþaretinin solunda ve saðýnda bazý sayýlar var. Tahmin edebileceðiniz gibi, soldaki sayýlar saðdaki sayýlarla iliþkili.

Peki bütün bu sayýlar ne anlama geliyor ve bu sayýlar arasýnda ne tür bir iliþki var?

Teknik olarak, bilgisayarlarýn temelinde sayýlar olduðunu duymuþsunuzdur. Bilgisayarýnýzda gördüðünüz her karakter aslýnda bir sayýya karþýlýk gelir. Zaten bilgisayarlar ‘a’, ‘b’, ‘c’, vb. kavramlarý anlayamaz. Bilgisayarlarýn anlayabildiði tek þey sayýlardýr. Mesela siz klavyeden ‘a’ harfini girdiðinizde bilgisayar bunu 97 olarak algýlar. Ya da siz ‘i’ harfi girdiðinizde, bilgisayarýn gördüðü tek þey 105 sayýsýdýr... Bu durumu Python’daki chr() adlý özel bir fonksiyon yardýmýyla teyit edebiliriz. Dikkatlice inceleyin:

>>> chr(97)

'a'

>>> chr(105)

'i'

>>> chr(65)

'A'

Gördüðünüz gibi, gerçekten de her sayý bir karaktere karþýlýk geliyor. Ýsterseniz bir de yukarýdaki sayý grubundaki sayýlarý denetleyelim:

for i in 214, 231, 220, 199, 304, 305, 286, 246, 351, 252, 350, 287:
print(i, chr(i))

Bu kodlarý çalýþtýrdýðýmýzda þu çýktýyý elde ediyoruz:

214 Ö
231 ç
220 Ü
199 Ç
304 Ý
305 ý
286 Ð
246 ö
351 þ
252 ü
350 Þ
287 ð

Bu çýktý sayesinde bazý þeyler zihninizde yavaþ yavaþ açýklýða kavuþuyor olmalý. Bu çýktý mesela 214 sayýsýnýn ‘Ö’ harfine, 220 sayýsýnýn ‘Ü’ harfine, 305 sayýsýnýn da ‘ý’ harfine karþýlýk geldiðini gösteriyor.

Burada iki nokta iþaretinin sol tarafýnda kalan sayýlarýn karakter karþýlýklarýný gördük. Bir de iki nokta iþaretinin sað tarafýnda kalan sayýlara bakalým:

for i in 79, 99, 85, 67, 73, 105, 71, 111, 115, 117, 83, 103:
print(i, chr(i))

Bu da þu çýktýyý verdi:

79 O
99 c
85 U
67 C
73 I
105 i
71 G
111 o
115 s
117 u
83 S
103 g

Burada da mesela 79 sayýsýnýn ‘O’ harfine, 85 sayýsýnýn ‘U’ harfine, 105 sayýsýnýn da ‘i’ harfine karþýlýk geldiðini görüyoruz.

Yukarýdaki ve yukarýdan bir önceki kodlarýn çýktýlarýný bir araya getirirseniz þöyle bir durumla karþý karþýya olduðunuzu görürsünüz:

Ö O
ç c
Ü U
Ç C
Ý I
ý i
Ð G
ö o
þ s
ü u
Þ S
ð g

Bütün bu söylediklerimizden þu sonuç çýkýyor:

çeviri_tablosu = str.maketrans(kaynak, hedef) satýrý, kaynak ve hedef olarak adlandýrdýðýmýz karakter dizilerini birleþtirip, bu deðiþkenler içindeki herbir karakteri birbiriyle eþleþtiriyor. Yani aþaðýdaki gibi bir iþlem yapýyor:

çeviri_tablosu = {"Ö": "O",
"ç": "c",
"Ü": "U",
"Ç": "C",
"Ý": "I",
"ý": "i",
"Ð": "G",
"ö": "o",
"þ": "s",
"ü": "u",
"Þ": "S",
"ð": "g"}

Burada çeviri_tablosu deðiþkeni içinde gösterdiðimiz biçimin Python’daki adý ‘sözlük’tür. Sözlükler de týpký karakter dizileri gibi bir veri tipidir. Bunlarý da birkaç bölüm sonra ayrýntýlý bir biçimde inceleyeceðiz. Biz burada, bazý þeyleri anlamamýzý kolaylaþtýracaðý için sözlük adlý veri tipini oldukça genel bir biçimde sizlere tanýttýk. Dediðim gibi, bu veri tipinin ayrýntýlarýný daha sonra inceleyeceðiz, ama yine de þu noktada sözlükleri kenarýndan köþesinden de olsa tanýmamýz bizim için faydalý olacaktýr.

Dediðim gibi, yukarýda çeviri_tablosu adýyla gösterdiðimiz þey bir sözlüktür. Bu sözlüðün nasýl çalýþtýðýný görmek için þöyle bir kod yazalým:

çeviri_tablosu = {"Ö": "O",
"ç": "c",
"Ü": "U",
"Ç": "C",
"Ý": "I",
"ý": "i",
"Ð": "G",
"ö": "o",
"þ": "s",
"ü": "u",
"Þ": "S",
"ð": "g"}

print(çeviri_tablosu["Ö"])

Bu kodlarý bir dosyaya kaydedip çalýþtýrýrsanýz þöyle bir çýktý alýrsýnýz:

O

Gördüðünüz gibi, sözlük içinde geçen “Ö” adlý öðeyi parantez içinde belirttiðimiz zaman, Python bize bu öðenin karþýsýndaki deðeri veriyor. Sözlük içinde “Ö” öðesinin karþýlýðý “O” harfi olduðu için de çýktýmýz “O” oluyor. Bir de þunlara bakalým:

çeviri_tablosu = {"Ö": "O",
"ç": "c",
"Ü": "U",
"Ç": "C",
"Ý": "I",
"ý": "i",
"Ð": "G",
"ö": "o",
"þ": "s",
"ü": "u",
"Þ": "S",
"ð": "g"}

print(çeviri_tablosu["Ö"])
print(çeviri_tablosu["ç"])
print(çeviri_tablosu["Ü"])
print(çeviri_tablosu["Ç"])
print(çeviri_tablosu["Ý"])
print(çeviri_tablosu["ý"])
print(çeviri_tablosu["Ð"])
print(çeviri_tablosu["ö"])
print(çeviri_tablosu["Þ"])
print(çeviri_tablosu["ð"])

Bu kodlarý çalýþtýrdýðýmýzda ise þöyle bir çýktý alýyoruz:

O
c
U
C
I
i
G
o
S
g

Gördüðünüz gibi, sözlük içinde iki nokta üst üste iþaretinin sol tarafýnda görünen öðeleri parantez içinde yazarak, iki nokta üst üste iþaretinin sað tarafýndaki deðerleri elde edebiliyoruz.

Bütün bu anlattýklarýmýzdan sonra þu satýrlarý gayet iyi anlamýþ olmalýsýnýz:

kaynak = "þçöðüýÞÇÖÐÜÝ"
hedef = "scoguiSCOGUI"

çeviri_tablosu = str.maketrans(kaynak, hedef)

Burada Python, kaynak ve hedef adlý deðiþkenler içindeki karakter dizilerini birer birer eþleþtirerek bize bir sözlük veriyor. Bu sözlükte:

"þ" harfi "s" harfine;
"ç" harfi "c" harfine;
"ö" harfi "o" harfine;
"ð" harfi "g" harfine;
"ü" harfi "u" harfine;
"ý" harfi "i" harfine;
"Þ" harfi "S" harfine;
"Ç" harfi "C" harfine;
"Ö" harfi "O" harfine;
"Ð" harfi "G" harfine;
"Ü" harfi "U" harfine;
"Ý" harfi "I" harfine

karþýlýk geliyor...

Kodlarýn geri kalanýnda ise þu satýrlarý görmüþtük:

metin = "Bildiðiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamýyoruz."

print(metin.translate(çeviri_tablosu))

Burada da orijinal metnimizi tanýmladýktan sonra translate() adlý metot yardýmýyla, çeviri tablosundaki öðe eþleþmesi doðrultusunda metnimizi tercüme ediyoruz. Bu kodlarda metin.translate(çeviri_tablosu) satýrýnýn yaptýðý tek þey çeviri_tablosu adlý sözlükteki eþleþme kriterlerini metin adlý karakter dizisine uygulamaktan ibarettir.

Karakter dizilerinin bu maketrans() adlý metodu kullaným olarak gözünüze öteki metotlardan farklý görünmüþ olabilir. Daha açýk bir dille ifade etmek gerekirse, bu metodu bir karakter dizisi üzerine deðil de str üzerine uyguluyor olmamýz, yani str.maketrans() yazýyor olmamýz sizi þaþýrtmýþ olabilir. Eðer anlamanýzý kolaylaþtýracaksa;

çeviri_tablosu = str.maketrans(kaynak, hedef)

satýrýný þu þekilde de yazabilirsiniz:

çeviri_tablosu = ''.maketrans(kaynak, hedef)

Yani maketrans() metodunu boþ bir karakter dizisi üzerine de uygulayabilirsiniz. Neticede maketrans() karakter dizilerinin bir metodudur. Bu metot hangi karakter dizisi üzerine uygulandýðýyla deðil, parametre olarak hangi deðerleri aldýðýyla (bizim örneðimizde kaynak ve hedef) ilgilenir. Dolayýsýyla bu metodu ilgili-ilgisiz her türlü karakter dizisine uygulayabilirsiniz:

çeviri_tablosu = 'mahmut'.maketrans(kaynak, hedef)
çeviri_tablosu = 'zalim dünya!'.maketrans(kaynak, hedef)

Ama tabii dikkat daðýtmamak açýsýndan en uygun hareket, bu karakter dizisini str üzerine uygulamak olacaktýr:

çeviri_tablosu = str.maketrans(kaynak, hedef)

Bu küçük ayrýntýya da dikkati çektiðimize göre yolumuza devam edebiliriz...

Yukarýda verdiðimiz örnek vasýtasýyla str.maketrans() ve translate() adlý metotlarý epey ayrýntýlý bir þekilde incelemiþ olduk. Dilerseniz pratik olmasý açýsýndan bir örnek daha verelim:

istihza.com sitemizin forum üyelerinden Barbaros Akkurt http://www.istihza.com/forum/viewtopic.php?f=25&t=63 adresinde þöyle bir problemden bahsediyor:

Ben on parmak Türkçe F klavye kullanýyorum. Bunun için, bazý tuþ kombinasyonlarý ile veya sistem tepsisi üzerindeki klavye simgesine týklayarak Türkçe Q - Türkçe F deðiþimi yapýyorum. Bazen bunu yapmayý unutuyorum ve bir metne bakarak yazýyorsam gözüm ekranda olmuyor. Bir paragrafý yazýp bitirdikten sonra ekranda bir karakter salatasý görünce çok bozuluyorum.

Ýþte böyle bir durumda yukarýdaki iki metodu kullanarak o karakter salatasýný düzeltebilirsiniz. Karakter salatamýz þu olsun:

Bfjflrk öa kdhsý yteua idjslyd bdcusldvdj ks?

Buna göre kodlarýmýzý yazmaya baþlayabiliriz. Öncelikle metnimizi tanýmlayalým:

metin = "Bfjflrk öa kdhsý yteua idjslyd bdcusldvdj ks?"

Þimdi de sýrasýyla q ve f klavye düzenlerini birer karakter dizisi haline getirelim:

q_klavye_düzeni = "qwertyuýopðüasdfghjklþi,zxcvbnmöç."
f_klavye_düzeni = "fgðýodrnhpqwuieaütkmlyþxjövcçzsb.,"

Burada amacýmýz yanlýþlýkla q klavye düzeninde yazýldýðý için karman çorman bir hale gelmiþ metni düzgün bir þekilde f klavye düzenine dönüþtürmek. Yani burada çýkýþ noktamýz (kaynaðýmýz) q_klavye_düzeni iken, varýþ noktamýz (hedefimiz) f_klavye_düzeni. Buna göre çeviri tablomuzu oluþturabiliriz:

çeviri_tablosu = str.maketrans(q_klavye_düzeni, f_klavye_düzeni)

Týpký bir önceki örnekte olduðu gibi, burada da çeviri_tablosu adlý deðiþkeni print() fonksiyonunu kullanarak yazdýrýrsanýz þöyle bir çýktýyla karþýlaþýrsýnýz:

{231: 46,
287: 113,
44 : 120,
46 : 44,
305: 110,
246: 98,
351: 121,
97 : 117,
98 : 231,
99 : 118,
100: 101,
101: 287,
102: 97,
103: 252,
104: 116,
105: 351,
106: 107,
107: 109,
108: 108,
109: 115,
110: 122,
111: 104,
112: 112,
113: 102,
114: 305,
115: 105,
116: 111,
117: 114,
118: 99,
119: 103,
120: 246,
121: 100,
122: 106,
252: 119}

Tahmin edebileceðiniz gibi, bu sözlükte iki nokta üst üste iþaretinin solundaki sayýlar q_klavye_düzeni adlý deðiþken içindeki karakterleri; saðýndaki sayýlar ise f_klavye_düzeni adlý deðiþken içindeki karakterleri temsil ediyor.

Son olarak translate() metodu yardýmýyla sözlükteki öðe eþleþmesini metin adlý deðiþkenin üzerine uyguluyoruz:

print(metin.translate(çeviri_tablosu))

Kodlarý topluca görelim:

metin = "Bfjflrk öa kdhsý yteua idjslyd bdcusldvdj ks?"

q_klavye_düzeni = "qwertyuýopðüasdfghjklþi,zxcvbnmöç."
f_klavye_düzeni = "fgðýodrnhpqwuieaütkmlyþxjövcçzsb.,"

çeviri_tablosu = str.maketrans(q_klavye_düzeni, f_klavye_düzeni)

print(metin.translate(çeviri_tablosu))

Ne elde ettiniz?

Yukarýdaki iki örnekte de gördüðümüz gibi, str.maketrans() metodu kaynak ve hedef karakter dizilerini alýp bunlarý birleþtirerek bize bir sözlük veri tipinde bir nesne veriyor. Yani týpký input() fonksiyonunun bize bir karakter dizisi verdiði gibi, str.maketrans() metodu da bize bir sözlük veriyor.

Eðer isterseniz, sözlüðü str.maketrans() metoduna oluþturtmak yerine, kendiniz de bir sözlük oluþturarak str.maketrans() metoduna parametre olarak atayabilirsiniz. Örneðin:

metin = "Bfjflrk öa kdhsý yteua idjslyd bdcusldvdj ks?"

sözlük = {"q": "f",
"w": "g",
"e": "ð",
"r": "ý",
"t": "o",
"y": "d",
"u": "r",
"ý": "n",
"o": "h",
"p": "p",
"ð": "q",
"ü": "w",
"a": "u",
"s": "i",
"d": "e",
"f": "a",
"g": "ü",
"h": "t",
"j": "k",
"k": "m",
"l": "l",
"þ": "y",
"i": "þ",
",": "x",
"z": "j",
"x": "ö",
"c": "v",
"v": "c",
"b": "ç",
"n": "z",
"m": "s",
"ö": "b",
"ç": ".",
".": ","}

çeviri_tablosu = str.maketrans(sözlük)
print(metin.translate(çeviri_tablosu))

Burada birbiriyle eþleþecek karakterleri kendimiz yazýp bir sözlük oluþturduk ve bunu parametre olarak doðrudan str.maketrans() metoduna verdik. Bu kodlarda kaynak ve hedef diye iki ayrý karakter dizisi tanýmlamak yerine tek bir sözlük oluþturduðumuz için, str.maketrans() metodunu iki parametreyle deðil, tek parametreyle kullandýðýmýza dikkat edin. Ayrýca sözlüðü nasýl oluþturduðumuzu da dikkatlice inceleyin.

Sözlükteki öðe çiftlerini böyle alt alta yazmamýzýn nedeni zorunluluk deðil, bir tercihtir. Ýstersek bu sözlüðü þöyle de tanýmlayabilirdik:

sözlük = {"q": "f", "w": "g", "e": "ð", "r": "ý", "t": "o", "y": "d", "u": "r",
"ý": "n", "o": "h", "p": "p", "ð": "q", "ü": "w", "a": "u", "s": "i",
"d": "e", "f": "a", "g": "ü", "h": "t", "j": "k", "k": "m", "l": "l",
"þ": "y", "i": "þ", ",": "x", "z": "j", "x": "ö", "c": "v", "v": "c",
"b": "ç", "n": "z", "m": "s", "ö": "b", "ç": ".", ".": ","}

Burada da öðe çiftlerini yan yana yazdýk. Bu iki yöntemden hangisi size daha okunaklý geliyorsa onu tercih edebilirsiniz.

Þimdi size bir soru sormama izin verin. Acaba aþaðýdaki metin içinde geçen bütün sesli harfleri silin desem, nasýl bir kod yazarsýnýz?

Bu programlama dili Guido Van Rossum adlý Hollandalý bir programcý tarafýndan 90’lý yýllarýn baþýnda geliþtirilmeye baþlanmýþtýr. Çoðu insan, isminin Python olmasýna bakarak, bu programlama dilinin, adýný piton yýlanýndan aldýðýný düþünür. Ancak zannedildiðinin aksine bu programlama dilinin adý piton yýlanýndan gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlý bir Ýngiliz komedi grubunun, Monty Python’s Flying Circus adlý gösterisinden esinlenerek adlandýrmýþtýr. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yýlan figürü ile temsil edilmesi neredeyse bir gelenek halini almýþtýr diyebiliriz.

Aklýnýza ilk olarak þöyle bir kod yazmak gelebilir:

metin = """Bu programlama dili Guido Van Rossum adlý Hollandalý bir
programcý tarafýndan 90'lý yýllarýn baþýnda geliþtirilmeye baþlanmýþtýr.
Çoðu insan, isminin Python olmasýna bakarak, bu programlama dilinin, adýný
piton yýlanýndan aldýðýný düþünür. Ancak zannedildiðinin aksine bu
programlama dilinin adý piton yýlanýndan gelmez. Guido Van Rossum bu
programlama dilini, The Monty Python adlý bir Ýngiliz komedi grubunun, Monty
Python's Flying Circus adlý gösterisinden esinlenerek adlandýrmýþtýr. Ancak
her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yýlan figürü ile temsil edilmesi neredeyse bir gelenek halini almýþtýr
diyebiliriz."""

sesli_harfler = "aeýioöuüAEIÝOÖUÜ"

yeni_metin = ""

for i in metin:
if not i in sesli_harfler:
yeni_metin += i

print(yeni_metin)

Burada öncelikle metin adlý bir deðiþken tanýmlayarak metnimizi bu deðiþken içine yerleþtirdik. Ardýndan da Türkçedeki sesli harfleri içeren bir karakter dizisi tanýmladýk.

Daha sonra da yeni_metin adlý boþ bir karakter dizisi oluþturduk. Bu karakter dizisi, orijinal metnin, sesli harfler ayýklandýktan sonraki halini barýndýracak. Biliyorsunuz, karakter dizileri deðiþtirilemeyen (immutable) bir veri tipidir. Dolayýsýyla bir karakter dizisi içinde yaptýðýmýz deðiþiklikleri koruyabilmek için bu deðiþiklikleri baþka bir deðiþken içinde tutmamýz gerekiyor.

Bu kodlarýn ardýndan bir for döngüsü tanýmlýyoruz. Buna göre, metin içinde geçen her bir karaktere tek tek bakýyoruz (for i in metin:) ve bu karakterler arasýnda, sesli_harfler deðiþkeni içinde geçmeyenleri, yani bütün sessiz harfleri (if not i in sesli_harfler:) tek tek yeni_metin adlý deðiþkene yolluyoruz (yeni_metin += i).

Son olarak da yeni_metin adlý karakter dizisini ekrana basýyoruz. Böylece orijinal metin içindeki bütün sesli harfleri ayýklamýþ oluyoruz.

Yukarýdaki, gayet doðru ve geçerli bir yöntemdir. Böyle bir kod yazmanýzýn hiçbir sakýncasý yok. Ama eðer isterseniz ayný iþi str.maketrans() ve translate() metotlarý yardýmýyla da halledebilirsiniz:

metin = """Bu programlama dili Guido Van Rossum adlý Hollandalý bir
programcý tarafýndan 90'lý yýllarýn baþýnda geliþtirilmeye baþlanmýþtýr.
Çoðu insan, isminin Python olmasýna bakarak, bu programlama dilinin, adýný
piton yýlanýndan aldýðýný düþünür. Ancak zannedildiðinin aksine bu
programlama dilinin adý piton yýlanýndan gelmez. Guido Van Rossum bu
programlama dilini, The Monty Python adlý bir Ýngiliz komedi grubunun, Monty
Python's Flying Circus adlý gösterisinden esinlenerek adlandýrmýþtýr. Ancak
her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yýlan figürü ile temsil edilmesi neredeyse bir gelenek halini almýþtýr
diyebiliriz."""

silinecek = "aeýioöuüAEIÝOÖUÜ"

çeviri_tablosu = str.maketrans('', '', silinecek)

print(metin.translate(çeviri_tablosu))

Burada da öncelikle metnimizi bir karakter dizisi içine yerleþtirdik. Daha sonra da þu kodu yazdýk:

silinecek = "aeýioöuüAEIÝOÖUÜ"

Bu kodlar yardýmýyla, metin içinden çýkarmak istediðimiz harfleri tek tek belirledik.

Ardýndan str.maketrans() fonksiyonumuzu yazarak çeviri tablosunu oluþturduk. Burada ilk iki parametrenin boþ birer karakter dizisi olduðuna dikkat ediyoruz. Ýlk iki parametreyi bu þekilde yazmamýzýn nedeni þu: Biz orijinal metin içindeki herhangi bir þeyi deðiþtirmek istemiyoruz. Bizim amacýmýz orijinal metin içindeki sesli harfleri silmek. Tabii o iki parametreyi yazmasak da olmaz. O yüzden o iki parametrenin yerine birer tane boþ karakter dizisi yerleþtiriyoruz.

Bu noktada çeviri_tablosu adlý deðiþkeni yazdýrarak neler olup bittiðini daha net görebilirsiniz:

{214: None,
97 : None,
101: None,
65 : None,
105: None,
111: None,
304: None,
305: None,
220: None,
117: None,
246: None,
73 : None,
79 : None,
252: None,
85 : None,
69 : None}

Gördüðünüz gibi, silinecek adlý deðiþken içindeki bütün karakterler None deðeriyle eþleþiyor... None ‘hiç, sýfýr, yokluk’ gibi anlamlara gelir. Dolayýsýyla Python, iki nokta üst üste iþaretinin sol tarafýndaki karakterlerle karþýlaþtýðýnda bunlarýn yerine birer adet ‘yokluk’ koyuyor! Yani sonuç olarak bu karakterleri metinden silmiþ oluyor...

Bu kodlarda iki nokta üst üste iþaretinin solundaki karakterlerin None ile eþleþmesini saðlayan þey, str.maketrans() metoduna verdiðimiz üçüncü parametredir. Eðer o parametreyi yazmazsak, yani kodlarýmýzý þu þekle getirirsek çeviri_tablosu deðiþkeninin çýktýsý farklý olacaktýr:

metin = """Bu programlama dili Guido Van Rossum adlý Hollandalý bir
programcý tarafýndan 90'lý yýllarýn baþýnda geliþtirilmeye baþlanmýþtýr.
Çoðu insan, isminin Python olmasýna bakarak, bu programlama dilinin, adýný
piton yýlanýndan aldýðýný düþünür. Ancak zannedildiðinin aksine bu
programlama dilinin adý piton yýlanýndan gelmez. Guido Van Rossum bu
programlama dilini, The Monty Python adlý bir Ýngiliz komedi grubunun, Monty
Python's Flying Circus adlý gösterisinden esinlenerek adlandýrmýþtýr. Ancak
her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yýlan figürü ile temsil edilmesi neredeyse bir gelenek halini almýþtýr
diyebiliriz."""

silinecek = "aeýioöuüAEIÝOÖUÜ"

çeviri_tablosu = str.maketrans('', '')

print(çeviri_tablosu)

Bu kodlarý çalýþtýrdýðýmýzda þöyle bir çýktý alýrýz:

{}

Gördüðünüz gibi, elde ettiðimiz þey boþ bir sözlüktür. Sözlük boþ olduðu, yani deðiþtirilecek herhangi bir karakter olmadýðý için bu kodlar orijinal metin üzerinde herhangi bir deðiþiklik yapmaz.

Ýsterseniz üçüncü parametrenin ne iþe yaradýðýný ve nasýl çalýþtýðýný daha iyi anlayabilmek için daha basit bir örnek verelim:

metin = "Cem Yýlmaz"

kaynak = "CY"
hedef = "cy"
silinecek = "eýa "

çeviri_tablosu = str.maketrans(kaynak, hedef, silinecek)

print(metin.translate(çeviri_tablosu))

Burada ‘C’ ve ‘Y’ harflerini sýrasýyla ‘c’ ve ‘y’ harfleriyle eþleþtirdik. Bu nedenle orijinal metin içindeki ‘C’ ve ‘Y’ harfleri yerlerini sýrasýyla ‘c’ ve ‘y’ harflerine býraktý. Silinecek karakterler olarak ise ‘e’, ‘ý’, ‘a’ ve boþluk karakterlerini seçtik. Böylece ‘Cem Yýlmaz’ adlý orijinal metin içindeki boþluk karakteri de silinerek, bu metin ‘cmylmz’ karakter dizisine dönüþtü.


isalpha()

Bu metot yardýmýyla bir karakter dizisinin ‘alfabetik’ olup olmadýðýný denetleyeceðiz. Peki ‘alfabetik’ ne demek?

Eðer bir karakter dizisi içinde yalnýzca alfabe harfleri (‘a’, ‘b’, ‘c’ gibi...) varsa o karakter dizisi için ‘alfabetik’ diyoruz. Bir örnekle bunu doðrulayalým:

>>> a = "kezban"
>>> a.isalpha()

True

Ama:

>>> b = "k3zb6n"
>>> b.isalpha()

False


isdigit()

Bu metot da isalpha() metoduna benzer. Bunun yardýmýyla bir karakter dizisinin sayýsal olup olmadýðýný denetleyebiliriz. Sayýlardan oluþan karakter dizilerine ‘sayý deðerli karakter dizileri’ adý verilir. Örneðin þu bir ‘sayý deðerli karakter dizisi’dir:

>>> a = "12345"

Metodumuz yardýmýyla bunu doðrulayabiliriz:

>>> a.isdigit()

True

Ama þu karakter dizisi sayýsal deðildir:

>>> b = "123445b"

Hemen kontrol edelim:

>>> b.isdigit()

False


isalnum()

Bu metot, bir karakter dizisinin ‘alfanümerik’ olup olmadýðýný denetlememizi saðlar. Peki ‘alfanümerik’ nedir?

Daha önce bahsettiðimiz metotlardan hatýrlayacaksýnýz:

Alfabetik karakter dizileri, alfabe harflerinden oluþan karakter dizileridir.

Sayýsal karakter dizileri, sayýlardan oluþan karakter dizileridir.

Alfanümerik karakter dizileri ise bunun birleþimidir. Yani sayý ve harflerden oluþan karakter dizilerine alfanümerik karakter dizileri adý verilir. Örneðin þu karakter dizisi alfanümerik bir karakter dizisidir:

>>> a = "123abc"

Ýsterseniz hemen bu yeni metodumuz yardýmýyla bunu doðrulayalým:

>>> a.isalnum()

True

Eðer denetleme sonucunda True alýyorsak, o karakter dizisi alfanümeriktir. Bir de þuna bakalým:

>>> b = "123abc>"
>>> b.isalnum()

False

b deðiþkeninin tuttuðu karakter dizisinde alfanümerik karakterlerin yanýsýra (“123abc”), alfanümerik olmayan bir karakter dizisi de bulunduðu için (“>”), b.isalnum() þeklinde gösterdiðimiz denetlemenin sonucu False (yanlýþ) olarak görünecektir.

Dolayýsýyla, bir karakter dizisi içinde en az bir adet alfanümerik olmayan bir karakter dizisi bulunursa (bizim örneðimizde ">"), o karakter dizisi alfanümerik olmayacaktýr.


isdecimal()

Bu metot yardýmýyla bir karakter dizisinin ondalýk sayý cinsinden olup olmadýðýný denetliyoruz. Mesela aþaðýdaki örnek ondalýk sayý cinsinden bir karakter dizisidir:

>>> a = "123"
>>> a.isdecimal()

True

Ama þu ise kayan noktalý (floating-point) sayý cinsinden bir karakter dizisidir:

>>> a = "123.3"
>>> a.isdecimal()

False

Dolayýsýyla a.isdecimal() komutu False çýktýsý verir...


isidentifier()

Identifier kelimesi Türkçede ‘tanýmlayýcý’ anlamýna gelir. Python’da deðiþkenler, fonksiyon ve modül adlarýna ‘tanýmlayýcý’ denir. Ýþte baþlýkta gördüðümüz isidentifier() metodu, neyin tanýmlayýcý olup neyin tanýmlayýcý olamayacaðýný denetlememizi saðlar. Hatýrlarsanýz deðiþkenler konusundan bahsederken, deðiþken adý belirlemenin bazý kurallarý olduðunu söylemiþtik. Buna göre, örneðin, deðiþken adlarý bir sayý ile baþlayamýyordu. Dolayýsýyla þöyle bir deðiþken adý belirleyemiyoruz:

>>> 1a = 12

Dediðimiz gibi, deðiþkenler birer tanýmlayýcýdýr. Dolayýsýyla bir deðiþken adýnýn geçerli olup olmadýðýný isidentifier() metodu yardýmýyla denetleyebiliriz:

>>> "1a".isidentifier()

False

Demek ki "1a" ifadesini herhangi bir tanýmlayýcý adý olarak kullanamýyoruz. Yani bu ada sahip bir deðiþken, fonksiyon adý veya modül adý oluþturamýyoruz. Ama mesela "liste1" ifadesi geçerli bir tanýmlayýcýdýr. Hemen denetleyelim:

>>> "liste1".isidentifier()

True


isnumeric()

Bu metot bir karakter dizisinin nümerik olup olmadýðýný denetler. Yani bu metot yardýmýyla bir karakter dizisinin sayý deðerli olup olmadýðýný denetleyebiliriz:

>>> "12".isnumeric()

True

>>> "dasd".isnumeric()

False


isspace()

Bu metot yardýmýyla bir karakter dizisinin tamamen boþluklardan oluþup oluþmadýðýný denetleyebiliriz. Eðer karakter dizimiz boþluklardan oluþuyorsa bu metot True çýktýsý verecek, ama eðer karakter dizimizin içinde bir tane bile boþluk harici karakter varsa bu metot False çýktýsý verecektir:

>>> a = " "
>>> a.isspace()

True

>>> a = "              "
>>> a.isspace()

True

>>> a = "" #karakter dizimiz tamamen boþ. Ýçinde boþluk karakteri bile yok...
>>> a.isspace()

False

>>> a = "fd"
>>> a.isspace()

False


isprintable()

Hatýrlarsanýz önceki derslerimizde \n, \t, \r ve buna benzer karakterlerden söz etmiþtik. Örneðin \n karakterinin ‘satýr baþý’ anlamýna geldiðini ve bu karakterin görevinin karakter dizisini bir alt satýra almak olduðunu söylemiþtik. Örnek verelim:

>>> print("birinci satýr\nikinci satýr")

birinci satýr
ikinci satýr

Bu örnekte \n karakterinin öteki karakterlerden farklý olduðunu görüyorsunuz. Mesela “b” karakteri komut çýktýsýnda görünüyor. Ama \n karakteri çýktýda görünmüyor. \n karakteri elbette yukarýdaki kodlar içinde belli bir iþleve sahip. Ancak karakter dizisindeki öteki karakterlerden farklý olarak \n karakteri ekranda görünmüyor. Ýþte Python’da bunun gibi, ekranda görünmeyen karakterlere ‘basýlmayan karakterler’ (non-printing characters) adý verilir. ‘b’, ‘c’, ‘z’, ‘x’, ‘=’, ‘?’, ‘!’ ve benzeri karakterler ise ‘basýlabilen karakterler’ (printable characters) olarak adlandýrýlýr. Ýþte baþlýkta gördüðünüz isprintable() metodu da karakterlerin bu yönünü sorgular. Yani bir karakterin basýlabilen bir karakter mi yoksa basýlmayan bir karakter mi olduðunu söyler bize. Örneðin:

>>> karakter = "a"
>>> karakter.isprintable()

True

Demek ki “a” karakteri basýlabilen bir karaktermiþ. Bir de þuna bakalým:

>>> karakter = "\n"
>>> karakter.isprintable()

False

Demek ki \n karakteri gerçekten de basýlamayan bir karaktermiþ.

Basýlamayan karakterlerin listesini görmek için http://www.asciitable.com/ adresini ziyaret edebilirsiniz. Listedeki ilk 32 karakter (0‘dan baþlayarak 32‘ye kadar olan karakterler) ve listedeki 127. karakter basýlamayan karakterlerdir.
